///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              15/Sep/2019  14:22:33
// Copyright 2004-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
//    Command line       =  
//        -f C:\Users\闫烁\AppData\Local\Temp\EW1A1B.tmp
//        (F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
//        -D NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D
//        MT_ZDO_FUNC -D SAPP_ZSTACK -lC
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
//        -lA
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
//        --diag_suppress Pe001,Pa010 -o
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 8 -f
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
//        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4095
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440) -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\ -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\ -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\include\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\include\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\high_level\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mt\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\osal\include\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\saddr\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\sdata\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\af\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\nwk\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sapi\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sec\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sys\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\zdo\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\
//        -I
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\f8w\
//        -Ohz --require_prototypes --no_code_motion)
//    Locale             =  Chinese (Simplified)_CHN.936
//    List file          =  
//        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List\SAPP_Device.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME SAPP_Device

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_ONE
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_DISP101_8
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC `??IRSendResAvailable::?relay`
        FUNCTION `??IRSendResAvailable::?relay`,0203H
        PUBLIC `??OutputExecuteBResAvailable::?relay`
        FUNCTION `??OutputExecuteBResAvailable::?relay`,0203H
        PUBLIC `??outputExecuteB::?relay`
        FUNCTION `??outputExecuteB::?relay`,0203H
        PUBLIC `??outputExecuteBTimeout::?relay`
        FUNCTION `??outputExecuteBTimeout::?relay`,0203H
        PUBLIC `??outputRemoter::?relay`
        FUNCTION `??outputRemoter::?relay`,0203H
        PUBLIC `??outputRemoterTimeout::?relay`
        FUNCTION `??outputRemoterTimeout::?relay`,0203H
        PUBLIC IRSendResAvailable
        FUNCTION IRSendResAvailable,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC OutputExecuteBResAvailable
        FUNCTION OutputExecuteBResAvailable,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBWEAK _A_P1
        PUBLIC funcCount
        PUBLIC funcList
        PUBLIC outputExecuteB
        FUNCTION outputExecuteB,0a1603H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 13, STACK
        PUBLIC outputExecuteBTimeout
        FUNCTION outputExecuteBTimeout,0a1603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC outputRemoter
        FUNCTION outputRemoter,0a1603H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC outputRemoterTimeout
        FUNCTION outputRemoterTimeout,0a1603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource SP:8, PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
GenIR               SYMBOL "GenIR"
`??GenIR::?relay`   SYMBOL "?relay", GenIR
HalIOSetLevel       SYMBOL "HalIOSetLevel"
`??HalIOSetLevel::?relay` SYMBOL "?relay", HalIOSetLevel
HalIOSetOutput      SYMBOL "HalIOSetOutput"
`??HalIOSetOutput::?relay` SYMBOL "?relay", HalIOSetOutput
IRSendInit          SYMBOL "IRSendInit"
`??IRSendInit::?relay` SYMBOL "?relay", IRSendInit
SendData            SYMBOL "SendData"
`??SendData::?relay` SYMBOL "?relay", SendData
memcpy              SYMBOL "memcpy"
`??memcpy::?relay`  SYMBOL "?relay", memcpy
IRSendResAvailable  SYMBOL "IRSendResAvailable"
`??IRSendResAvailable::?relay` SYMBOL "?relay", IRSendResAvailable
OutputExecuteBResAvailable SYMBOL "OutputExecuteBResAvailable"
`??OutputExecuteBResAvailable::?relay` SYMBOL "?relay", OutputExecuteBResAvailable
outputExecuteB      SYMBOL "outputExecuteB"
`??outputExecuteB::?relay` SYMBOL "?relay", outputExecuteB
outputExecuteBTimeout SYMBOL "outputExecuteBTimeout"
`??outputExecuteBTimeout::?relay` SYMBOL "?relay", outputExecuteBTimeout
outputRemoter       SYMBOL "outputRemoter"
`??outputRemoter::?relay` SYMBOL "?relay", outputRemoter
outputRemoterTimeout SYMBOL "outputRemoterTimeout"
`??outputRemoterTimeout::?relay` SYMBOL "?relay", outputRemoterTimeout

        EXTERN `??GenIR::?relay`
        FUNCTION `??GenIR::?relay`,00H
        EXTERN `??HalIOSetLevel::?relay`
        FUNCTION `??HalIOSetLevel::?relay`,00H
        EXTERN `??HalIOSetOutput::?relay`
        FUNCTION `??HalIOSetOutput::?relay`,00H
        EXTERN `??IRSendInit::?relay`
        FUNCTION `??IRSendInit::?relay`,00H
        EXTERN `??SendData::?relay`
        FUNCTION `??SendData::?relay`,00H
        EXTERN `??memcpy::?relay`
        FUNCTION `??memcpy::?relay`,00H
        EXTERN GenIR
        FUNCTION GenIR,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalIOSetLevel
        FUNCTION HalIOSetLevel,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN HalIOSetOutput
        FUNCTION HalIOSetOutput,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN IRSendInit
        FUNCTION IRSendInit,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN SendData
        FUNCTION SendData,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
//    1 #if defined(SAPP_ZSTACK)
//    2 #include "SAPP_Device.h"

        ASEGN SFR_AN:DATA:NOROOT,090H
// union <unnamed> volatile __sfr _A_P1
_A_P1:
        DATA8
        DS 1
//    3 #include "hal_io.h"
//    4 #include <string.h>
//    5 
//    6 /**************************************************************/
//    7 /* 传感器列表                                                 */
//    8 /**************************************************************/
//    9 /********************************/
//   10 /* 燃气传感器                   */
//   11 /********************************/
//   12 #if defined(HAS_GAS)
//   13 #define GAS_IO_GROUP        0
//   14 #define GAS_IO_BIT          0
//   15 void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//   16 void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//   17 {
//   18     if(type == ResInit)
//   19     {
//   20         HalIOSetInput(GAS_IO_GROUP, GAS_IO_BIT, Pull_Down);
//   21         HalIOIntSet(ep->ep, GAS_IO_GROUP, GAS_IO_BIT, IOInt_Rising, 0);
//   22     }
//   23     //IO端口中断触发，中断源检测
//   24     if(type == ResIOInt)
//   25     {
//   26         uint8 GasValue = 1;
//   27         SendData(ep->ep, &GasValue, 0x0000, TRANSFER_ENDPOINT, sizeof(GasValue));
//   28     }
//   29 }
//   30 void sensorGasTimeout(struct ep_info_t *ep);
//   31 void sensorGasTimeout(struct ep_info_t *ep)
//   32 {
//   33     uint8 value = HalIOGetLevel(GAS_IO_GROUP, GAS_IO_BIT);
//   34     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//   35 }
//   36 #endif
//   37 /********************************/
//   38 /* 温度传感器                   */
//   39 /********************************/
//   40 #if defined(HAS_TEMP) || defined(HAS_HUMM)
//   41 #include "sht10.h"
//   42 static uint16 TempValue = 0;
//   43 #endif
//   44 #if defined(HAS_TEMP)
//   45 void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//   46 void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//   47 {
//   48     if(type == ResInit)
//   49     {
//   50         SHT10_init(0x01);
//   51     }
//   52 }
//   53 void sensorTempTimeout(struct ep_info_t *ep);
//   54 void sensorTempTimeout(struct ep_info_t *ep)
//   55 {
//   56     unsigned int value = 0;
//   57     unsigned char checksum = 0;
//   58     SHT10_Measure(&value,&checksum, TEMPERATURE);
//   59     TempValue = (value << 2) - 3960;
//   60     SendData(ep->ep, &TempValue, 0x0000, TRANSFER_ENDPOINT, sizeof(TempValue));
//   61 }
//   62 #endif
//   63 /********************************/
//   64 /* 湿度传感器                   */
//   65 /********************************/
//   66 #if defined(HAS_HUMM)
//   67 void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//   68 void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//   69 {
//   70     if(type == ResInit)
//   71     {
//   72         SHT10_init(0x01);
//   73     }
//   74 }
//   75 void sensorHummTimeout(struct ep_info_t *ep);
//   76 void sensorHummTimeout(struct ep_info_t *ep)
//   77 {
//   78     const float C1 = -4.0f;              // for 8 Bit
//   79     const float C2 = +0.648f;            // for 8 Bit
//   80     const float C3 = -0.0000072f;        // for 8 Bit
//   81     const float T1 = 0.01f;              // for 8 bit
//   82     const float T2 = 0.00128f;           // for 8 bit
//   83     float rh_lin    =   0.0f;                     // rh_lin: Humidity linear
//   84     float rh_true   =   0.0f;                    // rh_true: Temperature compensated humidity
//   85     float t_C   = 0.0f;                        // t_C   : Temperature []
//   86 
//   87     unsigned int HumiValue = 0;
//   88     unsigned char checksum = 0;
//   89     SHT10_Measure(&HumiValue,&checksum, HUMIDITY);
//   90     rh_lin=C3*HumiValue*HumiValue + C2*HumiValue + C1;     //calc. humidity from ticks to [%RH]
//   91     rh_true=(t_C-25)*(T1+T2*HumiValue)+rh_lin;   //calc. temperature compensated humidity [%RH]
//   92     if(rh_true>100)
//   93         rh_true=100;       //cut if the value is outside of
//   94     if(rh_true<0.1)
//   95         rh_true=0.1f;       //the physical possible range
//   96     HumiValue = (unsigned int)(rh_true * 100);
//   97     SendData(ep->ep, &HumiValue, 0x0000, TRANSFER_ENDPOINT, sizeof(HumiValue));
//   98 }
//   99 #endif
//  100 /********************************/
//  101 /* 雨滴传感器                   */
//  102 /********************************/
//  103 #if defined(HAS_RAIN)
//  104 #define RAIN_IO_GROUP       0
//  105 #define RAIN_IO_BIT         0
//  106 void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  107 void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  108 {
//  109     if(type == ResInit)
//  110     {
//  111         HalIOSetInput(RAIN_IO_GROUP, RAIN_IO_BIT, Pull_None);
//  112         HalIOIntSet(ep->ep, RAIN_IO_GROUP, RAIN_IO_BIT, IOInt_Rising, 0);
//  113     }
//  114     //IO端口中断触发，中断源检测
//  115     if(type == ResIOInt)
//  116     {
//  117         uint8 RainValue = 1;
//  118         SendData(ep->ep, &RainValue, 0x0000, TRANSFER_ENDPOINT, sizeof(RainValue));
//  119     }
//  120 }
//  121 void sensorRainTimeout(struct ep_info_t *ep);
//  122 void sensorRainTimeout(struct ep_info_t *ep)
//  123 {
//  124     uint8 value = HalIOGetLevel(RAIN_IO_GROUP, RAIN_IO_BIT);
//  125     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  126 }
//  127 #endif
//  128 /********************************/
//  129 /* 火焰传感器                   */
//  130 /********************************/
//  131 #if defined(HAS_FIRE)
//  132 #define FIRE_IO_GROUP       0
//  133 #define FIRE_IO_BIT         0
//  134 void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  135 void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  136 {
//  137     if(type == ResInit)
//  138     {
//  139         HalIOSetInput(FIRE_IO_GROUP, FIRE_IO_BIT, Pull_Down);
//  140         HalIOIntSet(ep->ep, FIRE_IO_GROUP, FIRE_IO_BIT, IOInt_Rising, 0);
//  141     }
//  142     //IO端口中断触发，中断源检测
//  143     if(type == ResIOInt)
//  144     {
//  145         uint8 FireValue = 1;
//  146         SendData(ep->ep, &FireValue, 0x0000, TRANSFER_ENDPOINT, sizeof(FireValue));
//  147     }
//  148 }
//  149 void sensorFireTimeout(struct ep_info_t *ep);
//  150 void sensorFireTimeout(struct ep_info_t *ep)
//  151 {
//  152     uint8 value = HalIOGetLevel(FIRE_IO_GROUP, FIRE_IO_BIT);
//  153     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  154 }
//  155 #endif
//  156 /********************************/
//  157 /* 烟雾传感器                   */
//  158 /********************************/
//  159 #if defined(HAS_SMOKE)
//  160 #define SMOKE_IO_GROUP      0
//  161 #define SMOKE_IO_BIT        0
//  162 void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  163 void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  164 {
//  165     if(type == ResInit)
//  166     {
//  167         HalIOSetInput(SMOKE_IO_GROUP, SMOKE_IO_BIT, Pull_Down);
//  168         HalIOIntSet(ep->ep, SMOKE_IO_GROUP, SMOKE_IO_BIT, IOInt_Rising, 0);
//  169     }
//  170     //IO端口中断触发，中断源检测
//  171     if(type == ResIOInt)
//  172     {
//  173         uint8 SmokeValue = 1;
//  174         SendData(ep->ep, &SmokeValue, 0x0000, TRANSFER_ENDPOINT, sizeof(SmokeValue));
//  175     }
//  176 }
//  177 void sensorSmokeTimeout(struct ep_info_t *ep);
//  178 void sensorSmokeTimeout(struct ep_info_t *ep)
//  179 {
//  180     uint8 value = HalIOGetLevel(SMOKE_IO_GROUP, SMOKE_IO_BIT);
//  181     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  182 }
//  183 #endif
//  184 /********************************/
//  185 /* 光照度传感器                 */
//  186 /********************************/
//  187 #if defined(HAS_ILLUM)
//  188 #include "hal_adc.h"
//  189 void sensorILLumTimeout(struct ep_info_t *ep);
//  190 void sensorILLumTimeout(struct ep_info_t *ep)
//  191 {
//  192     uint16 LightValue = 256 - (HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3);
//  193     // 将AD值变换为光照度的100倍
//  194     LightValue = LightValue * 39;// * 10000 / 256;
//  195     SendData(ep->ep, &LightValue, 0x0000, TRANSFER_ENDPOINT, sizeof(LightValue));
//  196 }
//  197 #endif
//  198 /********************************/
//  199 /* 安防传感器                   */
//  200 /********************************/
//  201 #if defined(HAS_IRPERS)
//  202 #define SAFTY_IO_GROUP      1
//  203 #define SAFTY_IO_BIT        0
//  204 void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  205 void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  206 {
//  207     if(type == ResInit)
//  208     {
//  209         HalIOSetInput(SAFTY_IO_GROUP, SAFTY_IO_BIT, Pull_Down);
//  210         HalIOIntSet(ep->ep, SAFTY_IO_GROUP, SAFTY_IO_BIT, IOInt_Rising, 0);
//  211     }
//  212     //IO端口中断触发，中断源检测
//  213     if(type == ResIOInt)
//  214     {
//  215         uint8 IRPersValue = 1;
//  216         SendData(ep->ep, &IRPersValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRPersValue));
//  217     }
//  218 }
//  219 void sensorIRPersTimeout(struct ep_info_t *ep);
//  220 void sensorIRPersTimeout(struct ep_info_t *ep)
//  221 {
//  222     uint8 value = HalIOGetLevel(SAFTY_IO_GROUP, SAFTY_IO_BIT);
//  223     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  224 }
//  225 #endif
//  226 /********************************/
//  227 /* 红外测距传感器               */
//  228 /********************************/
//  229 #if defined(HAS_IRDIST)
//  230 #include "hal_adc.h"
//  231 extern uint16 irDistTab[256];
//  232 void sensorIRDistTimeout(struct ep_info_t *ep);
//  233 void sensorIRDistTimeout(struct ep_info_t *ep)
//  234 {
//  235     uint8 value = HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3;
//  236     // 计算距离值value的单位为mm
//  237     uint16 IRDistValue = irDistTab[value];
//  238     SendData(ep->ep, &IRDistValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRDistValue));
//  239 }
//  240 #endif
//  241 /********************************/
//  242 /* 语音传感器                   */
//  243 /********************************/
//  244 #if defined(HAS_VOICE)
//  245 #include "hal_uart.h"
//  246 static struct ep_info_t *voiceEndPoint = NULL;
//  247 static uint8 LastVoiceData = 0;
//  248 static void sensorVoiceUartProcess( uint8 port, uint8 event );
//  249 static void sensorVoiceUartProcess( uint8 port, uint8 event )
//  250 {
//  251     (void)event;  // Intentionally unreferenced parameter
//  252     while (Hal_UART_RxBufLen(port))
//  253     {
//  254         HalUARTRead(port, &LastVoiceData, 1);
//  255         if(LastVoiceData == 0xAA)
//  256             LastVoiceData = 1;
//  257         else if(LastVoiceData == 0x55)
//  258             LastVoiceData = 0;
//  259         else
//  260             LastVoiceData = -1;
//  261         if(voiceEndPoint != NULL)
//  262             SendData(voiceEndPoint->ep, &LastVoiceData, 0x0000, TRANSFER_ENDPOINT, 1);
//  263     }
//  264 }
//  265 void sensorVoiceNwkStateChange(struct ep_info_t *ep);
//  266 void sensorVoiceNwkStateChange(struct ep_info_t *ep)
//  267 {
//  268     voiceEndPoint = ep;
//  269 }
//  270 void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  271 void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  272 {
//  273     if(type == ResInit)
//  274     {
//  275         halUARTCfg_t uartConfig;
//  276 
//  277         voiceEndPoint = ep;
//  278         /* UART Configuration */
//  279         uartConfig.configured           = TRUE;
//  280         uartConfig.baudRate             = HAL_UART_BR_9600;
//  281         uartConfig.flowControl          = FALSE;
//  282         uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
//  283         uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
//  284         uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
//  285         uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
//  286         uartConfig.intEnable            = TRUE;
//  287         uartConfig.callBackFunc         = sensorVoiceUartProcess;
//  288         HalUARTOpen(HAL_UART_PORT_1, &uartConfig);
//  289     }
//  290 }
//  291 void sensorVoiceTimeout(struct ep_info_t *ep);
//  292 void sensorVoiceTimeout(struct ep_info_t *ep)
//  293 {
//  294     uint8 nulData = 0;
//  295     SendData(ep->ep, &nulData, 0x0000, TRANSFER_ENDPOINT, 1);
//  296 }
//  297 #endif
//  298 /********************************/
//  299 /* 二进制执行器传感器           */
//  300 /********************************/
//  301 #if defined(HAS_EXECUTEB)
//  302 #define ControlInit()   do { HalIOSetOutput(1,4);HalIOSetOutput(1,5);HalIOSetOutput(1,6);HalIOSetOutput(1,7);Control(0); } while(0)
//  303 #define Control(mask)   do { HalIOSetLevel(1,4,mask&0x01);HalIOSetLevel(1,5,mask&0x02);HalIOSetLevel(1,6,mask&0x04);HalIOSetLevel(1,7,mask&0x08); } while(0)
//  304 void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  305 void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
OutputExecuteBResAvailable:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function OutputExecuteBResAvailable
        CODE
//  306 {
        FUNCALL OutputExecuteBResAvailable, HalIOSetOutput
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetOutput
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetOutput
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetOutput
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL OutputExecuteBResAvailable, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV       A,R1
        MOV       R6,A
//  307     if(type == ResInit)
        MOV       A,#0x1
        XRL       A,R6
        JNZ       ??OutputExecuteBResAvailable_0
//  308         ControlInit();
        ; Setup parameters for call to function HalIOSetOutput
        MOV       R2,#0x4
        MOV       R1,#0x1
        LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
        ; Setup parameters for call to function HalIOSetOutput
        MOV       R2,#0x5
        MOV       R1,#0x1
        LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
        ; Setup parameters for call to function HalIOSetOutput
        MOV       R2,#0x6
        MOV       R1,#0x1
        LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
        ; Setup parameters for call to function HalIOSetOutput
        MOV       R2,#0x7
        MOV       R1,#0x1
        LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
        ; Setup parameters for call to function HalIOSetLevel
        MOV       R3,#0x0
        MOV       R2,#0x4
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        MOV       R3,#0x0
        MOV       R2,#0x5
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        MOV       R3,#0x0
        MOV       R2,#0x6
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        MOV       R3,#0x0
        MOV       R2,#0x7
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
//  309 }
??OutputExecuteBResAvailable_0:
        SJMP      ??Subroutine4_0
          CFI EndBlock cfiBlock0

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine0:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV       A,R6
        ADD       A,#0xb
        MOV       DPL,A
        CLR       A
        ADDC      A,R7
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??SendData::?relay`; Banked call to: SendData
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV       A,#0x1
        LCALL     ?DEALLOC_XSTACK8
          CFI EndBlock cfiBlock1
        REQUIRE ??Subroutine4_0
        ; // Fall through to label ??Subroutine4_0

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
??Subroutine4_0:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI NoFunction
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock2
//  310 void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  311 void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
outputExecuteB:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function outputExecuteB
        CODE
//  312 {
        FUNCALL outputExecuteB, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputExecuteB, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputExecuteB, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputExecuteB, HalIOSetLevel
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputExecuteB, SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 13, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 13, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV       A,#-0xb
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
        MOV       ?V0,R2
        MOV       ?V1,R3
        MOV       A,#0xb
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
//  313     //msg->Data[], msg->DataLength, msg->TransSeqNumber
//  314     Control(msg->Data[0]);
        MOV       A,R0
        ADD       A,#0x3
        MOV       R6,A
        CLR       A
        ADDC      A,R1
        MOV       R7,A
        ; Setup parameters for call to function HalIOSetLevel
        MOV       DPL,R6
        MOV       DPH,A
        LCALL     ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_5:
        MOV       C,0xE0 /* A   */.0
        CLR       A
        RLC       A
        MOV       R3,A
        MOV       R2,#0x4
        LCALL     ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_0:
        ANL       A,#0x2
        MOV       R3,A
        MOV       R2,#0x5
        LCALL     ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_1:
        ANL       A,#0x4
        MOV       R3,A
        MOV       R2,#0x6
        LCALL     ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_2:
        ANL       A,#0x8
        MOV       R3,A
        MOV       R2,#0x7
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
//  315     SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
        ; Setup parameters for call to function SendData
        MOV       ?V2,#0x1
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 13)
        MOV       R4,#0x0
        MOV       R5,#0x0
        MOV       DPL,R6
        MOV       DPH,R7
        MOVX      A,@DPTR
        MOV       R2,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R3,A
        LCALL     ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_3:
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
//  316 }
        MOV       R7,#0x3
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock3

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine1:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function outputExecuteB
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function outputExecuteB
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond5) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond5) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond5) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond5) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond5) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond5) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond5) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond5) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond5) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond5) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond5) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond5) CFA_SP SP+-2
          CFI (cfiCond5) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function outputExecuteB
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond6) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond6) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond6) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond6) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond6) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond6) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond6) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond6) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond6) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond6) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond6) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond6) CFA_SP SP+-2
          CFI (cfiCond6) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker7 Using cfiCommon1
          CFI (cfiPicker7) NoFunction
          CFI (cfiPicker7) Picker
        MOV       R1,#0x1
        LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        ; Setup parameters for call to function HalIOSetLevel
        MOV       DPL,R6
        MOV       DPH,R7
        LCALL     ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_6:
        RET
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiPicker7

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine3:
          CFI Block cfiCond8 Using cfiCommon0
          CFI Function outputExecuteB
          CFI Conditional ??CrossCallReturnLabel_5
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond9 Using cfiCommon0
          CFI (cfiCond9) Function outputExecuteB
          CFI (cfiCond9) Conditional ??CrossCallReturnLabel_6, ??CrossCallReturnLabel_0
          CFI (cfiCond9) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond9) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond9) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond9) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond9) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond9) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond9) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond9) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond9) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond9) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond9) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond9) CFA_SP SP+-4
          CFI (cfiCond9) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function outputExecuteB
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_6, ??CrossCallReturnLabel_1
          CFI (cfiCond10) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond10) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond10) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond10) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond10) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond10) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond10) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond10) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond10) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond10) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond10) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond10) CFA_SP SP+-4
          CFI (cfiCond10) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiCond11 Using cfiCommon0
          CFI (cfiCond11) Function outputExecuteB
          CFI (cfiCond11) Conditional ??CrossCallReturnLabel_6, ??CrossCallReturnLabel_2
          CFI (cfiCond11) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond11) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond11) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond11) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond11) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond11) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond11) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond11) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond11) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond11) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond11) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond11) CFA_SP SP+-4
          CFI (cfiCond11) CFA_XSP16 add(XSP16, 11)
          CFI Block cfiPicker12 Using cfiCommon1
          CFI (cfiPicker12) NoFunction
          CFI (cfiPicker12) Picker
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       DPH,A
        MOV       DPL,R0
        MOVX      A,@DPTR
        RET
          CFI EndBlock cfiCond8
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiCond11
          CFI EndBlock cfiPicker12
//  317 void outputExecuteBTimeout(struct ep_info_t *ep);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  318 void outputExecuteBTimeout(struct ep_info_t *ep)
outputExecuteBTimeout:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function outputExecuteBTimeout
        CODE
//  319 {
        FUNCALL outputExecuteBTimeout, SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV       A,#-0x1
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
//  320     uint8 value = P1 >> 4;
        MOV       A,0x90
        SWAP      A
        ANL       A,#0xf
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      @DPTR,A
//  321     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
        ; Setup parameters for call to function SendData
        MOV       ?V0,#0x1
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 11)
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R4,#0x0
        MOV       R5,#0x0
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP101_8
        LJMP      ?Subroutine0 & 0xFFFF
          CFI EndBlock cfiBlock13
        REQUIRE _A_P1
//  322 }
//  323 #endif
//  324 /********************************/
//  325 /* 模拟执行器传感器             */
//  326 /********************************/
//  327 #if defined(HAS_EXECUTEA)
//  328 void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
//  329 void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
//  330 {
//  331 }
//  332 #endif
//  333 /********************************/
//  334 /* 遥控器传感器                 */
//  335 /********************************/
//  336 #if defined(HAS_REMOTER)
//  337 #include "IR.h"

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  338 static uint8 lastCode[32];
lastCode:
        DS 32
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  339 static uint8 lastCodeLen = 0;
lastCodeLen:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  340 void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  341 void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
IRSendResAvailable:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function IRSendResAvailable
        CODE
//  342 {
        FUNCALL IRSendResAvailable, IRSendInit
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV       A,R1
        MOV       R6,A
//  343     if(type == ResInit)
        MOV       A,#0x1
        XRL       A,R6
        JNZ       ??IRSendResAvailable_0
//  344         IRSendInit();   // 需要初始化
        ; Setup parameters for call to function IRSendInit
        LCALL     `??IRSendInit::?relay`; Banked call to: IRSendInit
//  345 }
??IRSendResAvailable_0:
        LJMP      ??Subroutine4_0 & 0xFFFF
          CFI EndBlock cfiBlock14
//  346 void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  347 void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
outputRemoter:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function outputRemoter
        CODE
//  348 {
        FUNCALL outputRemoter, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputRemoter, GenIR
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputRemoter, SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        REQUIRE ?V3
        MOV       A,#-0xc
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV       ?V0,R2
        MOV       ?V1,R3
        MOV       A,#0xc
        LCALL     ?XSTACK_DISP0_8
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       DPL,R0
        MOV       DPH,A
//  349    lastCodeLen = msg->Data[0];
        INC       DPTR
        INC       DPTR
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R0,A
        INC       DPTR
        MOVX      A,@DPTR
        MOV       R1,A
        MOV       DPL,R0
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       DPTR,#lastCodeLen
        MOVX      @DPTR,A
//  350    memcpy(lastCode, &msg->Data[1], lastCodeLen);
        MOV       DPL,R0
        MOV       DPH,R1
        INC       DPTR
        MOV       R6,DPL
        MOV       R7,DPH
        ; Setup parameters for call to function memcpy
        MOV       ?V2,A
        MOV       ?V3,#0x0
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV       A,R6
        MOV       R4,A
        MOV       A,R7
        MOV       R5,A
        MOV       R2,#lastCode & 0xff
        MOV       R3,#(lastCode >> 8) & 0xff
        LCALL     `??memcpy::?relay`; Banked call to: memcpy
        MOV       A,#0x2
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
//  351    GenIR(&msg->Data[1], IRGuideLen_9ms, (uint8)lastCodeLen);
        ; Setup parameters for call to function GenIR
        MOV       DPTR,#lastCodeLen
        MOVX      A,@DPTR
        MOV       R4,A
        MOV       R1,#0x1
        MOV       A,R6
        MOV       R2,A
        MOV       A,R7
        MOV       R3,A
        LCALL     `??GenIR::?relay`; Banked call to: GenIR
//  352    SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
        ; Setup parameters for call to function SendData
        MOV       DPTR,#lastCodeLen
        MOVX      A,@DPTR
        RRC       A
        RRC       A
        RRC       A
        ANL       A,#0x1f
        MOV       ?V2,A
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 13)
        MOV       ?V2,#0x1
        MOV       R0,#?V2
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 14)
        MOV       R4,#0x0
        MOV       R5,#0x0
        MOV       R2,#lastCode & 0xff
        MOV       R3,#(lastCode >> 8) & 0xff
        LCALL     ?Subroutine2 & 0xFFFF
??CrossCallReturnLabel_4:
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
//  353 }
        MOV       R7,#0x4
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock15

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine2:
          CFI Block cfiCond16 Using cfiCommon0
          CFI Function outputExecuteB
          CFI Conditional ??CrossCallReturnLabel_3
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 13)
          CFI Block cfiCond17 Using cfiCommon0
          CFI (cfiCond17) Function outputRemoter
          CFI (cfiCond17) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond17) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI (cfiCond17) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI (cfiCond17) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond17) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond17) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond17) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond17) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond17) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond17) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond17) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond17) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond17) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond17) CFA_SP SP+-2
          CFI (cfiCond17) CFA_XSP16 add(XSP16, 14)
          CFI Block cfiPicker18 Using cfiCommon1
          CFI (cfiPicker18) NoFunction
          CFI (cfiPicker18) Picker
        MOV       A,?V0
        ADD       A,#0xb
        MOV       DPL,A
        CLR       A
        ADDC      A,?V1
        MOV       DPH,A
        MOVX      A,@DPTR
        MOV       R1,A
        LCALL     `??SendData::?relay`; Banked call to: SendData
        MOV       A,#0x2
        RET
          CFI EndBlock cfiCond16
          CFI EndBlock cfiCond17
          CFI EndBlock cfiPicker18
//  354 void outputRemoterTimeout(struct ep_info_t *ep);

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  355 void outputRemoterTimeout(struct ep_info_t *ep)
outputRemoterTimeout:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function outputRemoterTimeout
        CODE
//  356 {
        FUNCALL outputRemoterTimeout, SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL outputRemoterTimeout, SendData
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV       A,#-0x1
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV       A,R2
        MOV       R6,A
        MOV       A,R3
        MOV       R7,A
//  357     if(lastCodeLen <= 0)
        MOV       DPTR,#lastCodeLen
        MOVX      A,@DPTR
        JNZ       ??outputRemoterTimeout_0
//  358     {
//  359         uint8 value = 0;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        CLR       A
        MOVX      @DPTR,A
//  360         SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, 1);
        ; Setup parameters for call to function SendData
        MOV       ?V0,#0x1
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 11)
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R4,#0x0
        MOV       R5,#0x0
        MOV       A,#0x2
        LCALL     ?XSTACK_DISP101_8
        SJMP      ??outputRemoterTimeout_1
          CFI CFA_XSP16 add(XSP16, 10)
//  361     }
//  362     else
//  363         SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
??outputRemoterTimeout_0:
        ; Setup parameters for call to function SendData
        RRC       A
        RRC       A
        RRC       A
        ANL       A,#0x1f
        MOV       ?V0,A
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 11)
        MOV       ?V0,#0x1
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_ONE
          CFI CFA_XSP16 add(XSP16, 12)
        MOV       R4,#0x0
        MOV       R5,#0x0
        MOV       R2,#lastCode & 0xff
        MOV       R3,#(lastCode >> 8) & 0xff
??outputRemoterTimeout_1:
        LJMP      ?Subroutine0 & 0xFFFF
//  364 }
          CFI EndBlock cfiBlock19
//  365 #endif
//  366 /********************************/
//  367 /* 虚拟功能                     */
//  368 /********************************/
//  369 #if defined(HAS_TESTFUNCTION)
//  370 #define TEST_STRING     "Z-Stack for SAPP"
//  371 static uint8 lastData[119] = TEST_STRING;
//  372 static uint8 lastLen = 0;
//  373 void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
//  374 void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
//  375 {
//  376     lastLen = msg->DataLength;
//  377     memcpy(&lastData[sizeof(TEST_STRING) - 1], msg->Data, lastLen);
//  378     SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
//  379                      lastLen + sizeof(TEST_STRING) - 1);
//  380 }
//  381 void testFunc_TimeOut(struct ep_info_t *ep);
//  382 void testFunc_TimeOut(struct ep_info_t *ep)
//  383 {
//  384     SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
//  385                      lastLen + sizeof(TEST_STRING) - 1);
//  386 }
//  387 #endif
//  388 /********************************/
//  389 /* 广播发送功能                 */
//  390 /********************************/
//  391 #if defined(HAS_BROADCASTSEND)
//  392 #define BROADCAST_STRING     "\r\nBroadcast Message\r\n"
//  393 void BroadcastSend_TimeOut(struct ep_info_t *ep);
//  394 void BroadcastSend_TimeOut(struct ep_info_t *ep)
//  395 {
//  396     SendData(ep->ep, BROADCAST_STRING, 0XFFFF, TRANSFER_ENDPOINT,
//  397                      sizeof(BROADCAST_STRING) - 1);
//  398     //广播后指示灯 LED_D9 闪烁2次
//  399     HalLedBlink( HAL_LED_2, 2, 50, 100 );
//  400 }
//  401 #endif
//  402 /********************************/
//  403 /* 广播接收功能                 */
//  404 /********************************/
//  405 #if defined(HAS_BROADCASTRECEIVE)
//  406 void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
//  407 void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
//  408 {
//  409     //收到广播数据后 LED_D8 连续闪烁4次!
//  410     HalLedBlink( HAL_LED_1, 4, 50, 120 );
//  411     HalUARTWrite(HAL_UART_PORT_0, msg->Data, msg->DataLength);
//  412 }
//  413 #define BROADCAST_STRING     "Broadcast Message"
//  414 void BroadcastSend_TimeOut(struct ep_info_t *ep);
//  415 void BroadcastSend_TimeOut(struct ep_info_t *ep)
//  416 {
//  417     SendData(ep->ep, BROADCAST_STRING, 0X0000, TRANSFER_ENDPOINT,
//  418                      sizeof(BROADCAST_STRING) - 1);
//  419 }
//  420 #endif
//  421 /********************************/
//  422 /* IC卡读卡器                   */
//  423 /********************************/
//  424 #if defined(HAS_125KREADER)
//  425 #include "hal_uart.h"
//  426 #define CARDID_SIZE     5                   // 卡号长度
//  427 static uint8 lastCardId[CARDID_SIZE];       // 用来保存接收到的卡号
//  428 static uint8 cardRecvIdx;                   // 上一次接收到的长度
//  429 static uint32 lastTick;                     // 上一次接收数据的系统时间
//  430 static struct ep_info_t *cardEndPoint;
//  431 static void sensor125kReaderUartProcess( uint8 port, uint8 event );
//  432 static void sensor125kReaderUartProcess( uint8 port, uint8 event )
//  433 {
//  434     (void)event;  // Intentionally unreferenced parameter
//  435     if((lastTick + 100) <= osal_GetSystemClock())
//  436     {                                       // 如果本次接收到的时间距离上次超过了0.1秒
//  437         cardRecvIdx = 0;                    // 则清空计数器，重新接收卡号
//  438     }
//  439     lastTick = osal_GetSystemClock();       // 记录下当前的时间
//  440     while (Hal_UART_RxBufLen(port))
//  441     {
//  442         uint16 restLen = Hal_UART_RxBufLen(port);
//  443         if(restLen > (CARDID_SIZE - cardRecvIdx))
//  444             restLen = CARDID_SIZE - cardRecvIdx;
//  445         HalUARTRead(port, &lastCardId[cardRecvIdx], restLen);
//  446         cardRecvIdx += restLen;
//  447         if(cardRecvIdx >= CARDID_SIZE)      // 如果已经接收完成一个完整的卡号
//  448         {                                   // 则发送给协调器
//  449             SendData(cardEndPoint->ep, lastCardId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
//  450         }
//  451     }
//  452 }
//  453 void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  454 void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  455 {
//  456     if(type == ResInit)
//  457     {
//  458         halUARTCfg_t uartConfig;
//  459 
//  460         memset(lastCardId, 0, sizeof(lastCardId));
//  461         cardRecvIdx = 0;
//  462         cardEndPoint = ep;
//  463         /* UART Configuration */
//  464         uartConfig.configured           = TRUE;
//  465         uartConfig.baudRate             = HAL_UART_BR_19200;
//  466         uartConfig.flowControl          = FALSE;
//  467         uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
//  468         uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
//  469         uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
//  470         uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
//  471         uartConfig.intEnable            = TRUE;
//  472         uartConfig.callBackFunc         = sensor125kReaderUartProcess;
//  473         HalUARTOpen(HAL_UART_PORT_0, &uartConfig);
//  474     }
//  475 }
//  476 void sensor125kReaderTimeout(struct ep_info_t *ep);
//  477 void sensor125kReaderTimeout(struct ep_info_t *ep)
//  478 {
//  479     uint8 nullId[CARDID_SIZE] = { 0x00 };
//  480     SendData(cardEndPoint->ep, nullId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
//  481 }
//  482 #endif
//  483 /********************************/
//  484 /* 语音播放节点                 */
//  485 /********************************/
//  486 #if defined(HAS_SPEAKER)
//  487 void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  488 void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  489 {
//  490     if(type == ResInit)
//  491         HalUART1HwInit();
//  492 }
//  493 void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
//  494 void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
//  495 {
//  496     //msg->Data[], msg->DataLength, msg->TransSeqNumber
//  497     HalUART1HwTxByte(msg->Data[0]);
//  498 //    SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
//  499 }
//  500 void outputSpeakerTimeout(struct ep_info_t *ep);
//  501 void outputSpeakerTimeout(struct ep_info_t *ep)
//  502 {
//  503     uint8 value = 0;
//  504     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  505 }
//  506 #endif
//  507 /********************************/
//  508 /* 红外接收解码                 */
//  509 /********************************/
//  510 #if defined(HAS_IRDecode)
//  511 #include <hal_irdec.h>
//  512 void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
//  513 void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
//  514 {
//  515     if(type == ResInit)
//  516     {
//  517         IRDecodeT1Init(ep->task_id, ep->ep);
//  518     }
//  519     //定时器1通道0一次红外解码结束,向上传送解码结果
//  520     if(type == ResTimerInt)
//  521     {
//  522         OSALIRDecData_t *irData = (OSALIRDecData_t *)res;
//  523         SendData(ep->ep, irData->irCode, 0x0000, TRANSFER_ENDPOINT, irData->irLen);
//  524     }
//  525 }
//  526 void IRDecodeTimeout(struct ep_info_t *ep);
//  527 void IRDecodeTimeout(struct ep_info_t *ep)
//  528 {
//  529     uint8 value = 0;
//  530     SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
//  531 }
//  532 #endif
//  533 /***************************************************/
//  534 /* 节点功能列表                                    */
//  535 /***************************************************/

        RSEG XDATA_I:XDATA:NOROOT(0)
//  536 struct ep_info_t funcList[] = {
funcList:
        DATA8
        DS 66
        REQUIRE `?<Initializer for funcList>`
        REQUIRE __INIT_XDATA_I
//  537 #if defined(HAS_GAS)
//  538     {
//  539         // 加入网络,收到数据,超时处理,资源变化
//  540         NULL, NULL, sensorGasTimeout, sensorGasResAvailable,
//  541         { DevGas, 0, 5 },                   // type, id, refresh cycle
//  542     },
//  543 #endif
//  544 #if defined(HAS_TEMP)
//  545     {
//  546         NULL, NULL, sensorTempTimeout, sensorTempResAvailable,
//  547         { DevTemp, 1, 3 },                 // type, id, refresh cycle
//  548     },
//  549 #endif
//  550 #if defined(HAS_HUMM)
//  551     {
//  552         NULL, NULL, sensorHummTimeout, sensorHummResAvailable,
//  553         { DevHumm, 0, 3 },                 // type, id, refresh cycle
//  554     },
//  555 #endif
//  556 #if defined(HAS_ILLUM)
//  557     {
//  558         NULL, NULL, sensorILLumTimeout, NULL,
//  559         { DevILLum, 0, 3 },                // type, id, refresh cycle
//  560     },
//  561 #endif
//  562 #if defined(HAS_RAIN)
//  563     {
//  564         NULL, NULL, sensorRainTimeout, sensorRainResAvailable,
//  565         { DevRain, 0, 5 },                 // type, id, refresh cycle
//  566     },
//  567 #endif
//  568 #if defined(HAS_IRDIST)
//  569     {
//  570         NULL, NULL, sensorIRDistTimeout, NULL,
//  571         { DevIRDist, 0, 3 },               // type, id, refresh cycle
//  572     },
//  573 #endif
//  574 #if defined(HAS_SMOKE)
//  575     {
//  576         NULL, NULL, sensorSmokeTimeout, sensorSmokeResAvailable,
//  577         { DevSmoke, 0, 5 },                 // type, id, refresh cycle
//  578     },
//  579 #endif
//  580 #if defined(HAS_FIRE)
//  581     {
//  582         NULL, NULL, sensorFireTimeout, sensorFireResAvailable,
//  583         { DevFire, 0, 3 },                  // type, id, refresh cycle
//  584     },
//  585 #endif
//  586 #if defined(HAS_IRPERS)
//  587     {
//  588         NULL, NULL, sensorIRPersTimeout, sensorIRPersResAvailable,
//  589         { DevIRPers, 0, 2 },                // type, id, refresh cycle
//  590     },
//  591 #endif
//  592 #if defined(HAS_VOICE)
//  593     {
//  594         sensorVoiceNwkStateChange, NULL, sensorVoiceTimeout, sensorVoiceResAvailable,
//  595         { DevVoice, 0, 5 },                // type, id, refresh cycle
//  596     },
//  597 #endif
//  598 #if defined(HAS_EXECUTEB)
//  599     {
//  600         NULL, outputExecuteB, outputExecuteBTimeout, OutputExecuteBResAvailable,
//  601         { DevExecuteB, 3, 5 },              // type, id, refresh cycle
//  602     },
//  603 #endif
//  604 #if defined(HAS_EXECUTEA)
//  605     {
//  606         NULL, outputExecuteA, NULL, NULL,
//  607         { DevExecuteA, 0, 3 },              // type, id, refresh cycle
//  608     },
//  609 #endif
//  610 #if defined(HAS_REMOTER)
//  611     {
//  612         NULL, outputRemoter, outputRemoterTimeout, IRSendResAvailable,
//  613         { DevRemoter, 0, 3 },              // type, id, refresh cycle
//  614     },
//  615 #endif
//  616 #if defined(HAS_TESTFUNCTION)
//  617     {
//  618         NULL,
//  619         testFunc_RecvData,
//  620         testFunc_TimeOut,
//  621         NULL,
//  622         { DevTest, 0, 3 },
//  623     },
//  624 #endif
//  625 #if defined(HAS_BROADCASTSEND)
//  626     {
//  627         NULL,
//  628         NULL,
//  629         BroadcastSend_TimeOut,
//  630         NULL,
//  631         { DevBroadcastSend, 0, 3 },
//  632     },
//  633 #endif
//  634 #if defined(HAS_BROADCASTRECEIVE)
//  635     {
//  636         NULL,
//  637         BroadcastReceiveData,
//  638         BroadcastSend_TimeOut,
//  639         NULL,
//  640         { DevBroadcastReceive, 0, 30 },
//  641     },
//  642 #endif
//  643 #if defined(HAS_125KREADER)
//  644     {
//  645         NULL, NULL, sensor125kReaderTimeout, sensor125kReaderResAvailable,
//  646         { Dev125kReader, 0, 10 },
//  647     },
//  648 #endif
//  649 #if defined(HAS_SPEAKER)
//  650     {
//  651         NULL, outputSpeaker, outputSpeakerTimeout, OutputSpeakerResAvailable,
//  652         { DevSpeaker, 0, 9 },              // type, id, refresh cycle
//  653     },
//  654 #endif
//  655 #if defined(HAS_IRDecode)
//  656     {
//  657         NULL, NULL, IRDecodeTimeout, IRDecodeResAvailable,
//  658         { DevIRDecode, 0, 5 },              // type, id, refresh cycle
//  659     },
//  660 #endif
//  661 #if defined(ZDO_COORDINATOR)
//  662     {   // 协调器
//  663         CoordinatorNwkStateChangeRoutine,
//  664         CoordinatorIncomingRoutine,
//  665         CoordinatorTimeoutRoutine,
//  666         CoordinatorResAvailableRoutine,
//  667         { DevCoordinator, 0, 0 },
//  668     },
//  669 #elif defined(RTR_NWK)
//  670     {   // 路由器
//  671         RouterNwkStateChangeRoutine,
//  672         RouterIncomingRoutine,
//  673         RouterTimeoutRoutine,
//  674         RouterResAvailableRoutine,
//  675         { DevRouter, 0, 30 },
//  676     },
//  677 #endif
//  678 };
//  679 
//  680 // 不能修改下面的内容!!!

        RSEG XDATA_ROM_C:CONST:REORDER:NOROOT(0)
        DATA8
//  681 const uint8 funcCount = sizeof(funcList) / sizeof(funcList[0]);
funcCount:
        DB 2

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for funcList>`:
        DATA16
        DW 0H
        DW `??outputExecuteB::?relay`
        DW `??outputExecuteBTimeout::?relay`
        DW `??OutputExecuteBResAvailable::?relay`
        DATA8
        DB 11
        DB 3
        DB 5
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0
        DATA16
        DW 0H
        DW `??outputRemoter::?relay`
        DW `??outputRemoterTimeout::?relay`
        DW `??IRSendResAvailable::?relay`
        DATA8
        DB 13
        DB 0
        DB 3
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0, 0, 0
        DB 0, 0, 0, 0, 0, 0

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??OutputExecuteBResAvailable::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    OutputExecuteBResAvailable

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??outputExecuteB::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    outputExecuteB

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??outputExecuteBTimeout::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    outputExecuteBTimeout

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??IRSendResAvailable::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    IRSendResAvailable

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??outputRemoter::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    outputRemoter

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??outputRemoterTimeout::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    outputRemoterTimeout

        END
//  682 #endif
// 
// 538 bytes in segment BANKED_CODE
//  36 bytes in segment BANK_RELAYS
//   1 byte  in segment SFR_AN
//  66 bytes in segment XDATA_I
//  66 bytes in segment XDATA_ID
//   1 byte  in segment XDATA_ROM_C
//  33 bytes in segment XDATA_Z
// 
// 102 bytes of CODE     memory
//   1 byte  of CONST    memory
//   0 bytes of DATA     memory (+ 1 byte shared)
// 538 bytes of HUGECODE memory
//  99 bytes of XDATA    memory
//
//Errors: none
//Warnings: none
